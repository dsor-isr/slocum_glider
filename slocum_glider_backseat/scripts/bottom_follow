#! /usr/bin/env python

import rospy
from std_msgs.msg import Float32, Bool
from slocum_glider_msgs.srv import SetFloat64, SetMode


DESIRED_FLIGHT_BAND_SIZE = 30
MIN_FLIGHT_BAND_SIZE = 10

DESIRED_D_TARGET_ALTITUDE = 30
MIN_D_TARGET_ALTITUDE = 15

MIN_C_TARGET_DEPTH = 10

MAX_DEPTH = 100


class BottomFollower(object):
    def __init__(self,
                 desired_flight_band_size, min_flight_band_size,
                 desired_d_target_altitude, min_d_target_altitude,
                 min_c_depth,
                 max_depth):
        self.desired_flight_band_size = desired_flight_band_size
        self.min_flight_band_size = min_flight_band_size

        self.desired_d_target_altitude = desired_d_target_altitude
        self.min_d_target_altitude = min_d_target_altitude

        self.min_c_depth = min_c_depth
        self.max_depth = max_depth

        self.water_depth_sub = rospy.Subscriber('extctl/sensors/m_water_depth',
                                                Float32,
                                                self.water_depth_cb)
        self.set_c_target_depth = rospy.ServiceProxy('extctl/sensors/set_u_mission_param_a',
                                                     SetFloat64)
        self.set_d_target_depth = rospy.ServiceProxy('extctl/sensors/set_u_mission_param_b',
                                                     SetFloat64)
        self.set_mode = rospy.ServiceProxy('extctl/set_mode',
                                           SetMode)

        self.run = True
        self.stop_sub = rospy.Subscriber('BottomFollower/Stop',
                                         Bool,
                                         self.stop_cb)

    def abort(self):
        self.set_mode([1], [])

    def compute_optimal_d_target_depth(self, c_target_depth,
                                       desired_d_target_depth,
                                       water_depth):
        # c_target_depth should be equal to c_min_depth. Figure out how much to
        # shave from desired depth band size and desired d_target_altitude.
        #
        # For now, we will compress dive band first, to maintain safety.
        if (c_target_depth + self.min_flight_band_size) <= desired_d_target_depth:
            return desired_d_target_depth

        d_target_depth = (c_target_depth + self.min_flight_band_size)
        if (water_depth - d_target_depth) >= self.min_d_target_altitude:
            return d_target_depth

        # No solution, surface now!
        return -1

    def water_depth_cb(self, msg):
        "Whenever we get a water depth update, calculate new targets."
        water_depth = msg.data
        if water_depth == -1 or not self.run:
            return

        # Compute our desired dive depth
        desired_d_target_depth = min(water_depth
                                     - self.desired_d_target_altitude,
                                     self.max_depth)
        # Compute our desired climb depth
        desired_c_target_depth = (desired_d_target_depth
                                  - self.desired_flight_band_size)

        # If our desired climb depth is greater than our min depth, we're good
        # and need to do no more calculations
        if desired_c_target_depth >= self.min_c_depth:
            c_target_depth = desired_c_target_depth
            d_target_depth = desired_d_target_depth
        else:
            # Our min climb depth becomes our desired climb depth now.
            c_target_depth = self.min_c_depth
            d_target_depth = self.compute_optimal_d_target_depth(c_target_depth,
                                                                 desired_d_target_depth,
                                                                 water_depth)

        if d_target_depth == -1:
            self.abort()
        else:
            print('setting d_target_depth:', d_target_depth)
            print('setting c_target_depth:', c_target_depth)
            self.set_d_target_depth(d_target_depth)
            self.set_c_target_depth(c_target_depth)

    def stop_cb(self, msg):
        "Kill immediately."
        self.run = not msg.data


if __name__ == '__main__':
    rospy.init_node('bottom_follower')
    driver = BottomFollower(DESIRED_FLIGHT_BAND_SIZE,
                            MIN_FLIGHT_BAND_SIZE,
                            DESIRED_D_TARGET_ALTITUDE,
                            MIN_D_TARGET_ALTITUDE,
                            MIN_C_TARGET_DEPTH,
                            MAX_DEPTH)
    rospy.spin()
