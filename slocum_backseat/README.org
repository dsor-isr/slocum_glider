#+TITLE: Slocum Glider Backseat Driver Interface
#+AUTHOR: Eric Timmons

This package contains the interface between the glider and the programs running
on the secondary science computer, typically a Raspberry Pi or similar. This
secondary computer is called the "backseat driver" because it can get visibility
into the glider state and has (limited) ability to change the behavior of the
glider as it is executing a mission.

* Architecture

  This package provides a node that bridges serial communications with the
  glider and ROS. Additionally, it provides a script for parsing the extctl.ini
  file into a YAML file suitable for loading into the ROS parameter server. In
  the future it will also likely include client libraries that abstract away the
  need to subscribe directly to topics and services.

  The backseat driver must be connected to a serial port on the Glider's science
  computer. Currently, this serial connection is assumed to be 9600 baud 8N1.

  The primary node in this package is the =serial_backseat_interface= node. It
  is responsible for opening serial communications to the glider's science
  computer, parsing messages from the glider, and sending messages to the
  glider. Most glider communication is done using NMEA-inspired sentences. These
  messages start with a =$= and end in =*= followed by a two character (hex)
  checksum and a newline character. The checksum is the XOR of the characters
  between the =$= and =*= characters. The body of the message is a set of comma
  separated fields where the first field is a two character command and the
  remaining fields are its parameters.

* Features

  This section describes the different features of the
  =serial_backseat_interface= node as well as how to configure and use them.

  The serial port to listen on is configured by the following parameter:

  + =~serial_port/device= :: String naming the path to the serial port device
    used to communicate with the glider. Defaults to null, *must* be provided.

** extctl

   The backseat driver can communicate with the extctl proglet on the glider
   science computer to transfer files, en/disable glider behaviors, and read or
   write up to 32 sensors. To use this feature, the extctl proglet must be
   enabled in the science computer's =config\proglets.dat= file. See
   [[file:config/proglets.dat][proglets.dat]] for a snippet to include that enables it.

   When communicating with the extctl proglet, all glider sensors are referenced
   by an index. This index is determined by the =config\extctl.ini= file on the
   science computer. This file is a plain text file where each line contains
   either a sensor name and units for that sensor or is the string =os= or
   =is=. The first line of the file must be =os=. Every sensor/unit pair until
   the =is= line names sensors that can be written by the backseat driver. Every
   sensor/unit pair after the =is= line names sensors the glider reports to the
   backseat driver. The index of each sensor is its position in the list, with
   valid indices ranging from 0-31. The indices do *not* reset at the =is= line.

   The extctl feature is configured by the following parameters:

   + =~extctl/enabled= :: Defaults to =True=. If true, the extctl feature will
     be enabled.
   + =~extctl/auto/on_hi= :: Defaults to =True=. If true, the extctl feature
     will automatically fetch the extctl.ini file from the science computer upon
     receipt of any =HI= message.
   + =~extctl/auto/when_missing= :: Defaults to =True=. If true, the extctl
     feature will automatically fetch the extctl.ini file from the science
     computer if the =~extctl/mappings= key is not set.
   + =~extctl/mappings= :: A list of objects naming the sensors read or written
     over this interface. The index in the list corresponds to the index used to
     name the sensor over the wire. The keys of each object are =writeable=
     (bool), =name= (string), and =units= (string). This must be provided on
     node start or =~extctl/auto/when_missing= must be true.

*** Topics

    The following topics are published by this node.

    + =extctl/active= :: (=std_msgs/Bool=) True iff the extctl proglet is
      active.
    + =extctl/active_sensors= :: (=slocum_msgs/ActiveSensors=) Describes the
      sensors that are readable and writeable over the extctl interface.
    + =extctl/sensors/SENSOR_NAME= :: Every sensor in the =is= section of
      extctl.ini has its value published to the corresponding topic when a new
      value for it is received. The message type is one of
      =slocum_msgs/StampedFloat32=, =slocum_msgs/StampedFloat64=,
      =slocum_msgs/StampedBool=, or =slocum_msgs/StampedByte=, depending on the
      units of the underlying sensor.

*** Services

    The following services are provided by this node.

    + =extctl/load_extctl_ini= :: (=std_srvs/Trigger=) Forces the node to fetch
      and parse the extctl.ini file from the science computer.
    + =extctl/sensors/set_SENSOR_NAME= :: Set the value of the sensor on the
      glider. The sensor must appear in the =os= section of extctl.ini. The
      service type is one of =slocum_msgs/SetByte=, =slocum_msgs/SetBool=,
      =slocum_msgs/SetFloat32=, =slocum_msgs/SetFloat64=, depending on the units
      of the underlying sensor.
    + =extctl/get_file= :: (=slocum_msgs/GetFile=) Retrieve a file from the
      science computer's config directory and return it. The =name= field must
      be the (8+3) name of a file on the glider. The =contents= field will
      contain the contents of the file. If =block= is false, the service
      immediately returns a failure if a file transfer is already in progress,
      otherwise the file transfer is queued.
    + =extctl/send_file= :: (=slocum_msgs/SendFile=) Send a file to the glider's
      logs directory. The =name= field must be the (8+3) name of the file to
      write on the glider. The =contents= contains the file contents. If =block=
      is false, the service immediately returns a failure if a file transfer is
      already in progress, otherwise the file transfer is queued.
    + =extctl/set_mode= :: (=slocum_msgs/SetMode=) Toggle several mission modes
      simultaneously. =modes_to_activate= is a list of mode indices to enable
      and =modes_to_deactivate= is a list of mode indices to disable.

** Serial Console

   This node allows a glider operator to connect to a serial console running on
   the backseat driver through the glider comms. In order to support this, the
   =agetty= program must be installed on the backseat driver and the user
   running the node must be root (not recommended) or have permission to execute
   agetty as root through sudo with no password needed (see
   [[file:config/sudoers.d/50-backseat-interface-agetty][50-backseat-interface-agetty]]).

   This feature is configured by the following parameters:

   + =~tty/enabled= :: If true, the serial terminal feature is enabled. Defaults
     to =True=.
   + =~tty/agetty= :: Command to run when launching an agetty instance. Defaults
     to ="agetty"=.
   + =~tty/auto/enabled= :: Should agetty auto log in to a user
     account. Defaults to =False=
   + =~tty/auto/username= :: The user agetty should auto log in to. Defaults to
     the user running the node.

   To trigger this feature, connect to the science computer (using =consci=) and
   run the command:

   #+begin_src shell
     u4stalk $SERIAL_PORT_NUMBER 9600
   #+end_src

   then send the sentence: =$TT*06=. If the node can start a serial console, you
   will receive =$TS,S*7f= and agetty will be started based on the configuration
   provided through the parameter server. Otherwise, you will receive the
   sentence =$TS,F*6a= and no serial terminal will be started.

   **NOTE**: While the serial console is active the backseat driver cannot send
   or receive any other messages, so use it sparingly.

   **NOTE**: While u4stalk is active the backseat driver cannot send or receive
   any messages related to the extctl feature, so use it sparingly.
